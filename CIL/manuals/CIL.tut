┌──────────────────────────────────┐
│　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　│
│　　　　　　　　　　　ＣＩＬチュートリアル　　　　　　　　　　　　　│
│　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　│
│　　　　　　　　　　　　　　杉山岳弘　　　　　　　　　　　　　　　　│
│　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　│
│　　　　　　　　　　　　　１９９４年１月　　　　　　　　　　　　　　│
│　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　│
└──────────────────────────────────┘



●はじめに

　僕が阿部研に入った頃は、ただ、共通のルーチンがあっただけで、共通のラ
イブラリはなかった。それと、阿部研では画像を格納するのに、専用のフォー
マットを持っていて、そのルーチンは、それしかサポートしていなくて、ちょっ
と使いづらかった。それに、画像というのは色々な種類があって、二値画像、
濃淡画像、カラー画像、距離画像など、それぞれに応じて型宣言をするのは…。
また、共通のルーチンは、それぞれの人によって、多様化していて、ちょっと、
他の人が見るのは困難な状況になっていた。

  そこで、いろいろなフォーマットも読めて、また書き込みもできて、それで
もって、みんなが共通して使える統一されたライブラリがあるといいんじゃな
いかと思って、ＣＩＬの開発を行ないました。



●ＣＩＬで何ができる？

  ＣＩＬとは、「Computer で Image を扱う Library」 の略です。(chotto ii
libraryとも訳されます。)

  ＣＩＬでは、画像を扱うための共通のルーチンを提供する、ライブラリです。
言わば、コンピュータとユーザとのインターフェースを提供していると思って
下さい。ＣＩＬでは、以下のことが用意されています。

	・画像領域の確保などの基本操作
	・各種画像フォーマットのファイルの読み書き
	・画像に対しての各種グラフィックルーチン
	・基本的なフィルタ・ルーチン
	・Ｘウインドウ上への表示
	・Ｘツールキット・ライクなＸウインドウ・ライブラリ
	・共有メモリ、ソケット通信、複数ファイル、デバッグ、文字列操作
	　オプションの解析、タイマーなどの基本簡易操作ライブラリ

あと、ＣＩＬには、各種クライント達が準備されています。代表的なクライン
トは、以下の通りです。

	・imagedisp	各種画像をＸウインドウ上に表示する。
	・simpledisp	各種画像をＸウインドウ上に表示する。
	・imageedit	画像を編集する。
	・ifconv	画像のフォーマットを変換します。
	・makeresult	結果の画像などをまとめて一つの画像にします。
	・その他	フィルタ関係。

共有メモリに関してのコマンドも用意してあります。

	・cilserver	ＣＩＬサーバです。
	・cills		共有メモリ上の画像のリストをとる。
	・cilcp		共有メモリ上の画像をコピーする。
	・cilrm		共有メモリ上の画像を削除する。
	・cilview	ＣＩＬサーバによって画像を表示する。
			imagedispとは少し動作が異なる。

以上のように、画像を扱う上で基本的なツールやルーチンを準備したものが、
ＣＩＬだと考えて下さい。



●いきなり画像表示プログラム

　画像を表示するプログラムは、imagedisp、simpledisp、cilviewです。でも、
ここでは、ＣＩＬでのプログラミングの理解の第一歩として、画像を表示する
プログラムを組んでみましょう。「そんな、いきなり…」と、思うかも知れま
せんが、何のためのＣＩＬか考えて下さい。ＣＩＬは、プログラムを組む人と
コンピュータのユーザインタフェースの役目をしているのです。大丈夫です。

　さっそく、簡単なプログラムです。エラーチェックもありません。

	/*---------------------disp.c-----------------------*/
	#include "Image.h"

	int main(argc,argv)
	     int argc;
	     char *argv[];
	{
	  image src;
	  src = Image.createFromFilename( "SRC", argv[ 1 ] );
	  Image.display( src, 0 );
	  Image.destroy( src );
	  return 0;
	}
	/*--------------------------------------------------*/

　じゃ、コンパイルしてみよう。

　・sun4上では、
	% cc -I/home/abe/common/include disp.c \
		-L/home/abe/common/lib/sun4 -lcil
　・Solaris上では、
	% cc -I/home/abe/common/include disp.c \
		-L/home/abe/common/lib/sun5 -lcil -lsocket

でできあがりです。

　実行してみよう。

	とりあえず、サーバを起動して下さい。
	% cilserver
	% a.out /home/abe/common/j4file/hadairo_256

　どうですか、表示されましたか？

	初めてのことなのでサーバは切っておこう。
	% cilsever -f
	% cilsever -r

　関数や、サーバなどの詳しい説明はここではとりあえずしません。気にしな
いで下さい。大切なことは、以下に簡単にできるかです。通常でしたら、数百
行以上は必要です。さらに、画像のタイプによって色々表示できるようにする
には、数千行になります。しかし、ＣＩＬを使えば、わずか１０行程度ででき
ます。しかも、imagedispの機能をそのまま使うので、画像の拡大縮小や、線
形変換、ヒストグラム平滑化などが使えるので、「解析」、「デモ」、「デバッ
グ」などに便利です。

　ＣＩＬというのは、難しいものではないということが分かったと思います。
画像に関するプログラムを作る人をサポートする心強い味方だということが、
分かったんじゃないかな？（ちょっといいすぎかなぁ…）。



●フィルタ作ってみよう！

　じゃ、ＣＩＬを使って簡単なフィルタを作ってみよう。今度は、画像を加工
するという作業です。詳しい説明は抜きにして、フィルタ類の典型例を見てい
きましょう。例によってエラーチェックはないです。

	/*--------------------------------------------------*/
	#include "Image.h"
	#include <stdio.h>

	void thresholding( dest, src, threshold )
	     image dest;
	     image src;
	     long threshold;
	{
	  register long x, y, xsize, ysize;
	  register uchar **sdata;
	  register bit1 **ddata;

	  sdata = ( uchar ** )Image.data( src );
	  xsize = Image.xsize( src );
	  ysize = Image.ysize( src );

	  Image.make( dest, Bit1, xsize, ysize );
	  ddata = ( bit1 ** )Image.data( dest );

	  for ( y = 0; y < ysize; y++ )
	    for ( x = 0; x < xsize; x++ )
	      {
		if ( sdata[ y ][ x ] > threshold ) ddata[ y ][ x ] = 1;
		else				   ddata[ y ][ x ] = 0;
	      }
	}

	int main( argc, argv )
	      int argc;
	      char *argv[];
	{
	  image dest, src;
	  long threshold;

	  src  = Image.createFromFilename( "src", argv[ 1 ] );
	  dest = Image.create( "dest" );
	  threshold = atol( argv[ 3 ] );

	  thresholding( dest, src, threshold );

	  Image.save( dest, argv[ 2 ], "Thresholding" );

	  Image.destroy( dest );
	  Image.destroy( src );
	}
	/*--------------------------------------------------*/

　「なっ、長い」と思った人もいるでしょう。まぁ、フィルタだったらこんな
もんでしょう。別に長くないよ。見てみると、何かわけの分からないところが
あるねぇ。一番不思議なのは、関数なのに、"." がついているところだね。こ
れは、ちょっと細工がしてあって、こういったことができるんだ。こうしてみ
てみると、"Image."というのは、何か画像の基本的な操作を行なうような感じ
がするでしょう。まとまっている。"Image."というのは、型 image に対する
基本操作を行なう関数だよ、って意味なんだ。この関数群を通して、画像の属
性の変更や参照を行なうことができる。他の方法で、変更することを禁止して
いるんだね。これは、ＣＩＬの重要な約束事なので、守って下さい。

　じゃ、"Image."にはどういった関数があるのか、基本的なのを紹介しよう。

	image 型のテンプレートを生成します。画像には名前をつけよう。
	image Image.create( char * name );

	image 型を破壊します。いらなくなったら破壊しよう。
	void Image.destroy( image self );
	
	image 型の属性を表示します。デバッグに。
	void Image.print( image self );

	ファイルから読み込みます。色々なフォーマットが読めるよ。
	void Image.load( image self, char *filename );

	ファイルから書き込みます。コメントは重要。
	void Image.save( image self, char *filename, char *comment );

	画像の領域の確保を行ないます。型に注意。
	void Image.make( image self, long type, long xsize, long ysize );

	画像の領域の解放を行ないます。いらなくなったら解放しよう。
	void Image.free( image self );

	画像をコピーします。
	void Image.copy( image self, image src );

	属性を参照する関数。必ずこの関数で参照してね。
	char *Image.name( image self );		名前
	long  Image.type( image self );		画素の型
	long  Image.xsize( image self );	Ｘサイズ
	long  Image.ysize( image self );	Ｙサイズ
	char **Image.data( image self );	２次元配列へのポインタ

	ファイルから読み込んで画像を生成する。便利な関数。
	image Image.createFromFilename( char *name, char *filename );

	領域を確保して画像を生成する。便利な関数。
	image Image.createMake( char *name, long type,
				long xsize, long ysize );

	Ｘウインドウ上に表示する。内部で imagedisp を呼び出すよ。
	void Image.display( image self, char *option_string );

	Image.displayで表示したのを、閉じる。
	void Image.undisplay( image self );


　でも、これは、一部です。その他に、便利なマクロ集などもあります。詳し
くは、ＣＩＬマニュアルなどを参照して下さい。

　ここでは、あの上のプログラムを全部理解するのではなくて、「へぇー」ぐ
らいに、思ってくれればいいよ。あと、何か image 型を操作したり、参照し
たりする時は、"Image." で始まる関数を使うんだなぁ、ということを分かっ
ていて欲しい。

　次のところで、プログラムを組む上で必要なことを説明していくよ。



●さて、今度は自分で作ってみよう！

　今までは、説明調だったけど、今度は、誰かに登場してもらって、実際にプ
ログラムを作ってもらおう。それじゃぁ、「MIKE」に、やってもらいましょう。

MIKE> 「MIKE」です。よろしくお願いします。
EXPERT> よろしく。

MIKE>	何を作ろうかな…？
	何もないなぁ。やめた。ばいばい。

EXPERT> ちょいまち。それじゃ、これをつくってもらおう。

MIKE>	うえぅ。

EXPERT> じゃぁ、まずは簡単なものから。「ＳＯＢＥＬフィルタ」いってみようか。

MIKE>	ＯＫ…。

MIKE>	えっと、まず、ＳＯＢＥＬの処理をする部分をつくろう。
	引数は、オリジナルと処理後の画像だけだな。

	void sobel( dest, src )
	     image dest;
	     image src;

	と、こんな感じかな。
	さて、上の例を見習って…

	{
	  register long x, y, xsize, ysize;
	  register uchar **sdata;
	  register bit1 **ddata;

	これでよし。さて次は…

EXPERT> ごほんごほん。MIKE、型は大丈夫なの？

MIKE>	型…？

EXPERT> 画素の型だよ。画像には画素の型があるから、それを受ける配列のポ
	インタの型をしっかり決めておかなければいけないんだよ。

MIKE>	ほー。そうなのか。で、ＳＯＢＥＬの出力はどれくらいなのかな？
	uchar でいい？

EXPERT> ソーベルの出力は、かなり大きくなるので、ushort や float を使う。
	しかし、ＣＩＬでは、ushort は、ラベル画像として定義付けられて
	いるので、float を使おう。
	ＣＩＬでは、一般的に、何かの大きさや量を表す場合は、float を勧
	めます。

MIKE>	それじゃ、float にしてと。

	{
	  register long x, y, xsize, ysize;
	  register uchar **sdata;
	  register float **ddata;

	と。お次は、サイズと原画像の配列のポインタをとってきて、

	  sdata = ( uchar ** )Image.data( src );
	  xsize = Image.xsize( src );
	  ysize = Image.ysize( src );

	よしと。

EXPERT> ＯＫ。ＯＫ。

MIKE>	つづいては、ソーベルの出力を格納する領域の確保とそのポインタを
	とってきて…。

	  Image.make( dest, Bit1, xsize, ysize );
	  ddata = ( bit1 ** )Image.data( dest );

	じゃなくて、これは、float に変更したから、

	  Image.make( dest, Float, xsize, ysize );
	  ddata = ( float ** )Image.data( dest );

EXPERT> ＧＯＯＤ、ＧＯＯＤ。

MIKE>	後は、ループで回せば、いいかな…。げ、面倒っちいなぁ。

	  for ( y = 0; y < ysize; y++ )
	    for ( x = 0; x < xsize; x++ )
	      {
	      }

	うーん、大きさだから、ｘ方向の値と、ｙ方向の値が必要で、それの
	大きさを計算するから、げげ、なんかすごく面倒じゃない？
	ヘルプEXPERT！

EXPERT> うーむ、じゃぁ、畳み込みのフィルタの一つの仕方を説明しよう。
	ＳＯＢＥＬは３×３のオペレータを用いるので、これを最初に定義し
	てしまおう。

	  static long sobel_op[3][3] = { { -1, 0, 1 },
					 { -2, 0, 2 },
					 { -1, 0, 1 } };

	これで、よし。

	次に、畳み込みの部分は、

	  dx = dy = 0;
	  for ( yy = -1; yy <= 1; yy++ )
	    for ( xx = -1; xx <= 1; xx++ )
	      {
		p = sdata[ y + yy ][ x + xx ];
		dx += p * sobel_op[ yy + 1 ][ xx + 1 ];
		dy += p * sobel_op[ xx + 1 ][ yy + 1 ];
	      }

	こうすればいい。気をつけなければいけないことは、この方法だと、
	画像の一りは、計算できないということ。それに参照するところが、
	画像の内部になるようにしなければ、いけないので、全体ではどうな
	るかというと、

	  long dx, dy, p;
	  for ( y = 1; y < ysize - 1; y++ )
	    for ( x = 1; x < xsize - 1; x++ )
	      {
		dx = dy = 0;
		for ( yy = -1; yy <= 1; yy++ )
		  for ( xx = -1; xx <= 1; xx++ )
		    {
		      p = sdata[ y + yy ][ x + xx ];
		      dx += p * sobel_op[ yy + 1 ][ xx + 1 ];
		      dy += p * sobel_op[ xx + 1 ][ yy + 1 ];
		    }
		ddata[ y ][ x ] = sqrt(( double )( dx * dx + dy * dy ));
	      }

	以上。

MIKE>	ふーむ、なーるほどねぇ。フィルタのオペレータを宣言しておいて、あ
	とは内側にもう一つループを入れればいいのか。これなら、一般的に
	適用できそうだなぁ。まぁ、画像のはしっこが計算できないのはしょ
	うがないけど。

EXPERT> もちろん、はしっこを計算する一般的な方法もあるので、みなさん各
	自考えてみて下さい。

MIKE>	とりあえず、いままでのをまとめてみるか、

	void sobel( dest, src )
	     image dest;
	     image src;
	{
	  register long x, y, xsize, ysize;
	  register uchar **sdata;
	  register float **ddata;
	  register long dx, dy, p;

	  static long sobel_op[3][3] = { { -1, 0, 1 },
					 { -2, 0, 2 },
					 { -1, 0, 1 } };

	  sdata = ( uchar ** )Image.data( src );
	  xsize = Image.xsize( src );
	  ysize = Image.ysize( src );

	  Image.make( dest, Float, xsize, ysize );
	  ddata = ( float ** )Image.data( dest );

	  for ( y = 1; y < ysize - 1; y++ )
	    for ( x = 1; x < xsize - 1; x++ )
	      {
		dx = dy = 0;
		for ( yy = -1; yy <= 1; yy++ )
		  for ( xx = -1; xx <= 1; xx++ )
		    {
		      p = sdata[ y + yy ][ x + xx ];
		      dx += p * sobel_op[ yy + 1 ][ xx + 1 ];
		      dy += p * sobel_op[ xx + 1 ][ yy + 1 ];
		    }
		ddata[ y ][ x ] = sqrt(( double )( dx * dx + dy * dy ));
	      }
	}

	よしと。

	さて、お次は、呼び出しの部分だな。

	int main( argc, argv )
	      int argc;
	      char *argv[];
	{
	  image dest, src;

	  src  = Image.createFromFilename( "src", argv[ 1 ] );
	  dest = Image.create( "dest" );

	  sobel( dest, src );

	  Image.save( dest, argv[ 2 ], "Sobel" );

	  Image.destroy( dest );
	  Image.destroy( src );
	}

	真似て変更したけどどうかな？

EXPERT> 何やっているか分かる？

MIKE>	…、うーむ。どうも、"create"の意味がいまいち飲み込めない。
	"create"は何をするの？

EXPERT> ＯＫ。説明しよう。

	image dest, src;

	の行では、ただ、image型として、dest と src を使います、と宣言
	しただけで、実際には存在していないんだ。存在していないというの
	は、名前だけで、実際には、実体を持っていない状態にあるんだ。
	さらに、言うと、image型は構造体のポインタ型で、構造体そのもの
	じゃないんだ。

MIKE>	はぁ？

EXPERT>	あの…、構造体とか、ポインタとか分かる？

MIKE>	ちょっと、いまいち…。

EXPERT>	そうか。
	構造体というのは、何か一つのまとまった単位で、色々な属性で構成
	されているもの。例えば、人ならば、

	人＝｛名前、年齢、職業、出身、…｝

	といったように、属性を、一つにまとめると、考えやすくなるし、扱
	いやすくなるでしょ。

	それで、構造体のポインタというのは、そのまとまった単位である構
	造を指し示しているもの。実際にimage型はどう宣言されているかと
	いうと、

	typedef struct imageRec {
	  char  *name;
	  long   type;
	  long   xsize;
	  long   ysize;
	  char **data;
	} *image;

	こう宣言されているんだ。

	画像＝｛名前、画素型、Ｘサイズ、Ｙサイズ、データへのポインタ｝

	このように画像の持つ属性をまとめて構造体で宣言してあって、かつ
	image型は、そのポインタとして宣言してあるんだ。ポインタで宣言
	する理由の一つは、関数の引き渡しをすべて、値渡しでなくて、変数
	渡しにするため。

MIKE>	あの…。

EXPERT>	なに？

MIKE>	ちょっと、話しが難しいんだけど…。

EXPERT>	そっか…。どこまでわかった？

MIKE>	…。構造体とかはわかった。けど、ポインタとかはいまいちつかめな
	いなぁ。

EXPERT>	そうだね、ポインタとかは、いろいろプログラム組んだ人でないとイ
	メージがつかみにくいかなぁ。まぁ、これから勉強していこう。

MIKE>	がんばりまーす。

EXPERT>	ＯＫ。じゃ、とりあえずのところは、image使う時は、最初にcreate
	しなきゃいけないんだな、ということ覚えといて。それと、もう使わ
	なくなったimageは、destroyしておくことも。

MIKE>	うん。createとdestroyは、対になっているんだね。

EXPERT>	そう。

EXPERT>	それじゃ、Image.saveだけど、これは、画像をファイルにセーブする
	関数だけど、引数の意味は、

	Image.save( 画像、ファイル名、コメント );

	になっている。コメントを甘く見てちゃいけないよ。非常に重要な引
	数だよ。確かになくてもいいのだけれども、必要ないからといって何
	も書かないのはよくない。何も書かないのは初心者にありがちなんだ
	けどね。じゃ、コメントの重要性は、

		コメントは、画像がどのような処理をされて生成されたか、
		伝えることができる。また、その処理におけるパラメータ値
		を付け加えることにすれば、自分のためにも、この画像を参
		照する人にも、有益な情報を与えることができ、その画像の
		持つ価値が増す。

		コメントがない画像は、明らかに何の画像か分かればいいの
		だが、そうでない画像は、ただ見るだけで、それ以外の価値
		を持たなくなって、研究などの重要な用途では利用できなく
		なってしまう。

	ということです。

MIKE>	なるほど、気にしていなかったことだ。コメントは分かりやすく書こ
	うっと。

EXPERT>	じゃ、ついでに、名前に関しても話しておこう。よく、プログラムな
	どで、変数名や関数名など、名前をつけるのに困ってしまって、全然
	意味のない名前をつけちゃう人がいる。これは、非常によくない。名
	前は、すごく重要です。プログラムの理解を助けることになるし、ま
	た、デバッグにも、多くの情報を与えてくれます。何よりも、人が見
	て分かることが大事です。人が見て理解できない（難しくて分からな
	いのではなくて、意味不明で分からない）ものは、時が立てば、必ず、
	作った本人でさえ分からなくなってしまい、最終的にそのプログラム
	は、ゴミ箱いきなります。こういうプログラムは、バグとともに、し
	つこく生き続けようとするので、とにかく、理解不能なプログラムは
	書かないことです。特に、複雑な処理のプログラムで、こういった事
	態に陥った場合は、最悪で、架空の伝説「この処理をプログラムする
	のは難しい」が生まれ、「ないよりはましだから、見にくいけど、こ
	のプログラムに頑張ってもらおう」という処置がとられがちです。こ
	うなったら最後、このプログラムはバグをばらまきながら、時間と手
	間を食い尽くしていきます。これは、ただ単に、理解しにくいプログ
	ラムを組んでしまったがために、架空の伝説が生まれてしまったので
	す。なんてことはない、どんなに複雑な処理をすることでも、必ず、
	人間が理解できる、思考の単位があるのです。まず、これを考えて、
	プログラミングに入るべきでしょう。
	　ちょっと、名前の話しから、プログラムの話しになってしまったけ
	ど、プログラムを組む上での名前の重要性に話しを戻そう。名前の決
	め方は、

		１：意味のある名前をつける。

		２：抽象名でなく具体名を使う。
		    単に「画像」ではなく「エッジ画像」とか。

		３：省略文字はできるだけ避ける。
		    ・たいていのコンパイラは変数名に２５６文字使える
		    ・また、長い名前が入力するのが面倒と考えている人は、
		      間違い。NEmacsには補間機能があること忘れずに。

		４：例え、同じ型でも、変数の使い回しを考えて名前を決め
		    ない。

		５：同じグループの中の名前をつける時は、命名規則をしっ
		    かりと考えてからつける。

	これぐらいが、あげられるかな。

MIKE>	うーむ、なんか、話しが、プログラミングの話しになってきたなぁ。

EXPERT>	脱線は重要。

MIKE>	でも、いろいろ参考になるね。このあたりの話しは、常識の部類には
	いると思うけど、知らないよなぁ。ついつい、見落されがちな話しだ
	なぁ。

EXPERT>	まぁ、これを機会にプログラム技術を向上させて。ちなみに、コンピュー
	タ関係の勉強したならこれぐらいは知ってて欲しい。

	脱線ついでに、プログラムのコメントに関して言っておきたいことが
	ある。コメントの重要性は先ほど述べたように、プログラムのコメン
	トも、もっと重要です。理解できるプログラムを書くことにも関連し
	ているので、ここで、説明しておくね。

	プログラムの中に書くコメントは、ただ、やっていることを書くので
	はなくて、思考の単位でどういったことを行なうのか書く。

	例えば、

		for ( i = 0; i < n; i++ )

	に対して、

		i を 0 から n-1 までループする。

	とは書かないで、

		〜を n 回繰り返す。

	とか書く。

	また、見て明らかなことは書かない。

		i++; /* iを１進める */

	とは書かない。	

	プログラムのコードの中に「コメントの多いプログラム」と、「コメ
	ントの少ないプログラム」のどちらが良いかと言えば、少ない方がい
	いのである。もちろん、少ないだけでなく、いかに少ないコメントで、
	プログラムが理解できるように書くかが重要である。もちろん、人に
	よって理解の深さはあるので、その評価は難しいが、少なくとも、１
	年後に自分が見て理解できるプログラムが書ければいいと思う。

	じゃ、どういうプログラムを書けば、理解しやすくて、分かりやすい
	コメントを入れることができるか、が問題になる。これには、前にも、
	出てきたけど、思考の単位でプログラムを捕らえていく能力が要求さ
	れる。「思考の単位」ってなに？と思うかもしれないけど、これは、
	いつも言われていることで、モジュール化に関連している。問題を抽
	象レベルの階層にうまく分離して、解いていく方法である。これが、
	うまくできるかできないかで、プログラムの善し悪しが決まってくる
	といっていい。もちろん、こういう思考単位で書かれたプログラムは、

		１：変更に強い。
		２：拡張性に富んでいる。
		３：読みやすい。
		４：バグが入りにくい。
		５：デバッグが簡単である。

	といった、利点がある。こういったプログラムを書かなければならな
	いのである。

	プログラムを書き上げていくときも、思考の単位で書いていけば、楽
	に書けると思う。極端な話しに聞こえるかも知れないが、問題を良く
	理解しているならば、紙の上で考えなくても、いきなり、プログラム
	を書くことだってできる。これは、決してできないことじゃない。

	コメントの話しに戻すが、そういったプログラムが書ければ、あとは
	思考を助けるようにコメントを書いていけばよい。もちろん、思考の
	単位でプログラムにコメントを入れていけばいいのである。プログラ
	ムを作る時に考えたことをそのまま書いていけばいい。

	次に、「〜の最大値を求める」ところを作ろうかな、と思って書いた
	コードには、

		/* 〜の最大値を求める */

	と書けば十分である。思考の抽象レベルの階層にそれぞれのコメント
	を入れていくわけだから、うまく、コメントを段付けして、書いてい
	き、プログラム中からコメントだけを抽出すれば、理想的には、それ
	だけで、アルゴリズム、つまり、プログラムの要約が抽出できる。

	もちろん、これは、プログラムコード内のコメントであって、プログ
	ラム全体のコメント、つまり、プログラムの説明書は、理想的には、
	誰が読んでも使えるような説明書を書くことが望まれる。それと、説
	明書には、チュートリアル、デモ、リファレンスなども書いておくと、
	親切である。

MIKE>	長げー説明だなぁ。
	すぐやれといわれて、できるもんでもないし。

EXPERT>	もちろん、慣れるまではうまくできないかもしれないけど、やらなけ
	れば、いつまでたっても、手間と時間を無駄使いしてしまうことにな
	るよ。あと、人に受け渡されるプログラムなら、なおさらだよ。その
	人に、多大な負担をかけることになるよ。運良く、すべて作り直す判
	断ができればいいけど、そのまま継続になってしまっては、考えるだ
	けでも恐ろしい。良いプログラムと悪いプログラムを見分ける目を持
	つことも重要だね。

MIKE>	なるほど、自分のためでもあり人のためでもあり、やらなけらばなら
	ないことなんだね。

EXPERT>	ぜひ、そうしてください。あと、人に見てもらって、分かり難いとこ
	ろを指摘してもらうといいと思う。これは、誰にでも頼めることだし、
	全然知らない人の方が、良く知っている人より、本質をついていると
	思うよ。

MIKE>	なるほど。おもしろいね。

EXPERT>	さて、脱線話もそろそろ終りにして、もとに戻ろう。

MIKE>	ちょっと、わからないとこあるんだけど。

EXPERT>	どこ？

MIKE>	Image.xsize、Image.ysizeは、分かるんだ。でも、Image.dataってい
	うのが、どうも、つかめない。

EXPERT>	なるほど。画像の最小単位は画素であることは知っていると思うけど、
	画像は、この画素の二次元配列で構成されているんだ。

MIKE>	それで、それで。

EXPERT>	ということは、画素をアクセスするためには、その配列のポインタが
	必要なんだ。

MIKE>	げ、また、ポインタだ。

EXPERT>	二次元配列だよ、使ったことあるでしょ？

MIKE>	うん。同じなの？

EXPERT>	同じように扱っていいよ。

MIKE>	じゃわかる。それで。

EXPERT>	Image.dataは、その二次元配列のポインタを返す関数なんだ。

MIKE>	なーるほど。それは、わかったけど、あの、前についている、
	( float ** )ってなに？

EXPERT>	あれは、Ｃ言語の、型変換、キャストというやつだよ。
	Image.dataの返す型は、すべて、( char ** ) を返すんだけど、
	実際には、画像の画素型によって、配列のポインタの型は違ってくる
	わけだよ。だから、そのために、型変換をするんだ。

MIKE>	ほー、なかなか、難しいことやるんだね。

MIKE>	あと、配列を参照する時に、sdata[y][x] となっているのは？
	sdata[x][y]のほうが、わかりやすいんだけど。

EXPERT>	これは、Ｃ言語の配列の扱い上、仕方ないことなんだよ。指定は、行、
	列の順だからね。もし、それがいやなら、マクロを書くといいよ。

	#define PIXEL_VALUE( ptr, x, y ) ((ptr)[y][x])

	とかね。

MIKE>	それは、いいアイデアだね。

MIKE>	あ、そうそう、register 宣言がされているけど、なにか意味あるの？

EXPERT>	あれはね、コンパイラに変数をレジスタに割り当てもらうためにする
	んだよ。

MIKE>	それは分かるけど、つけるのと、つけないのとでは、どれくらい違う
	のとか。

EXPERT>	そうだね、まず、register をつけるのは、

		ポインタ、int、long

	などだね。実験によると、つけるのと、つけないのでは、約１．５倍
	くらいになるかな。適切な場所に、うまくやれば、効果的だよ。

MIKE>	なるほど、スピードも重要だね。特に、画像処理ではね。

EXPERT>	そうだね。

MIKE>	ふっ…。（つかれた）。

EXPERT>	だいたい、わかったか？

MIKE>	つかれたけど、なんとか。

EXPERT>	じゃ、ちょっと、休憩。



●さらに使えるものにしよう！

EXPERT>	さきほどのプログラムは、まだ完成じゃないよ。

MIKE>	なんで。もう、全部書いたじゃん。

EXPERT>	だめだめ、あれじゃ、コンパイルもできないし、とても、他の人が安
	心して使えるものじゃないよ。

MIKE>	別にいいもん。自分しか使わんもん。

EXPERT>	そうはいかない。
	たとえ、自分しか使わないと思っているプログラムでも、自分が使お
	うと思ったプログラムだから、だれかしら、使いたいと言う人が出て
	くると思っていた方がいい。

MIKE>	厳しいのね…。

EXPERT>	そう、作る以上は、残すことを考えて作って。そうでなきゃ、二度手
	間どころじゃ済まなくなるから。とにかく、トータルで見て、プログ
	ラム効率を上げることを考えて。

MIKE>	長い目で先を読みとる力が必要なんだね。

EXPERT>	そうだよ。

MIKE>	じゃ、どうすればいいの？

EXPERT>	それでは、人が使えるプログラムを説明しよう。

	１：どんな入力にも耐える。
	２：エラーは的確に出し、分かるように。
	３：分かりやすい使い方を出す。
	４：汎用性を重視。
	５：できるだけ、ユーザの要望に応える。

	これらの条件を満たせていれば、いいかな。

	コマンドラインの引数チェックや、画像の型チェック、パラメータの
	チェックなど、いろいろ押えておきたい点はある。

	まず、コマンドラインの引数チェックから。

	簡単な場合は、単純な処理で済ませてしまえばいいけど、たくさんオ
	プションがある時は、ＣＩＬｍｉｓｃライブラリの optlib を使うと
	いい。この場合、入力と出力だけなので、簡単に済ませてしまおう。

	じゃ、下のようなものはどうだろうか？

	int main( argc, argv )
	      int argc;
	      char *argv[];
	{
	  image source_image;
	  image  sobel_image;
	  char *source_filename = "-";
	  char * sobel_filename = "-";

	  /* 何も引数がなければ、ヘルプを表示して終了 */
	  if ( argc < 1 )
	    {
	      printf( "Usage: sobel <input-image> [output-image]\n" );
	      exit( 1 );
	    }

	  /* ファイル名のチェック */
	  if ( argc < 1 ) source_filename = argv[ 1 ];
	  if ( argc < 2 )  sobel_filename = argv[ 2 ];

	  /* 画像を生成と読み込む */
	  source_image = Image.createFromFilename( "source", source_filename );
	  sobel_image  = Image.create( "sobel" );

	  /* ファイルが読み込めなければ終了 */
	  if ( source_image == 0 )
	    {
	      fprintf( stderr, "error:sobel:can't open file (%s)\n",
		       source_filename );
	      exit( -1 );
	    }

	  /* 濃淡画像でなければ終了 */
	  if ( Image.type( source_image ) != UChar )
	    {
	      fprintf( stderr,
		       "error:sobel:The image (%s) type is wrong (%s).\n",
		       source_filename, typename( Image.type( source_image )));
	      exit( -1 );
	    }

	  /* ソーベルフィルタをかける */
	  sobel( sobel_image, source_image );

	  /* 画像をファイルに書き込む */
	  Image.save( sobel_image, sobel_filename, "Sobel" );

	  /* 画像の解放をする */
	  Image.destroy( source_image );
	  Image.destroy(  sobel_image );
	}

	ちょっと、コメントが多いような気がするけど初めてだからよしとし
	よう。基本的には上の流れでいいと思う。

MIKE>	コメントと、引数のチェック、その他のエラー処理がついたんだね。

EXPERT>	そう。わかる？

MIKE>	こう見ていると、目新しいことはないから大丈夫だと思う。

EXPERT>	少し解説しよう。
	ファイル名の初期値は、"-" になっているけど、これは、標準入力、
	標準出力という意味があることを覚えておいて欲しい。引数がなけれ
	ば、ヘルプを表示して終了している。このときの終了コードは、１に
	してある。

		exit(  1 );	正の値：なにかの理由があって終了する時
		exit( -1 );	負の値：エラーによって続行できなくなった時
		exit(  0 );	ゼ  ロ：正常終了

	ということも、頭に入れておくといいかも知れない。また、メッセー
	ジをどこに出力するかもよく分からない人がいるといけないので、説
	明しておこう。

		エラーメッセージ、デバッグ：
			標準エラー出力	stderr
			fprintf( stderr, .... );

		その他のメッセージなど：
			標準出力	stdout
			printf( .... );

	普通は、上のように使い分ける。

MIKE>	へー、そんな使いわけをしているのか、知らなかった…。

EXPERT>	ＣＩＬのルールだよ。覚えておいてね。特に、終了コードは重要だか
	ら、正常の時は、勝手に終らずに、exit( 0 ); などで、必ず、終了
	コード０で終了してね。

MIKE>	へーい。

MIKE>	終り？

EXPERT>	まだ。includeファイルの指定がない。

	#include "Image.h"
	#Include <stdio.h>
	#Include <math.h>

	と最初に付け加える。

MIKE>	なんで、""、<>、に使い分けているの？

EXPERT>	これは、includeファイルを探しにいくパスの順番の制御を行なって
	いるんだ。つまり、

	"" で、囲んである場合は、

		ユーザの指定しているincludeパス
		/usr/include
		/usr/local/include

	の順番で探しにいく。

	<> で、囲んである場合は、

		/usr/include
		/usr/local/include
		ユーザの指定しているincludeパス

	の順番で探しにいく。

	だから、通常、ローカルなincludeファイルは、"" で囲んで、標準の
	includeファイルの場合は、<> で囲む。

MIKE>	へー、いろいろ、あるんだなぁ。

EXPERT>	そうだね。そこが結構いやらしいとこだね。
	さて、これで、コンパイルの準備はできたわけだ。

MIKE>	いよいよですね。

EXPERT>	やりかたは、

	SunOS4.* の場合は、
	% cc sobel.c -I/home/abe/common/include \
		-L/home/abe/common/lib/sun4 -lcil -lm

	Solarisの場合は、
	% cc sobel.c -I/home/abe/common/include \
		-L/home/abe/common/lib/sun5 -lcil -lm -lsocket

	でできます。

MIKE>	ほー、よくわからない、オプションがあるなぁ。

EXPERT>	説明するよ、

	-I は、ユーザのincludeパスを指定しているんだ。
	-L は、ユーザのlibraryパスを指定しているんだ。
	-lcil	は、cil ライブラリを参照すること。
	-lm	は、math ライブラリを参照すること。
	-lsocketは、socket ライブラリを参照すること。

MIKE>	なるほど、そうか。cil ライブラリね…。

EXPERT>	これで、できあがりってわけだ。

MIKE>	なにもしてないけど、できてしまった…。

EXPERT>	まぁ、最初だからね。
	今度は、cilserver を使って、効率のよい画像の扱い方を学ぼう。
	cilserver は、ＣＩＬのもう一つの顔です。しっかりと、使い方を覚
	えよう。


●cilserver で遊ぼう！

　ＣＩＬでは、画像をファイルシステムからだけでなく、共有メモリも画像ファ
イルとして同等に（ここがポイント）取り扱うことができます。これには、
ＣＩＬサーバが必要です。共有メモリを使うとどんな良いことがあるか？

	１：一時的な画像の退避場所に使える
	２：ファイルとして残るわけではないので、ディスクの節約になる。
	３：高速に読み書きができる。
	４：デバッグ用の画像のモニターをしたいときに使える。

ということがあげられます。工夫次第で、いろいろ使えると思います。

　使いかたは簡単。

	% cilserver

で起動します。これで、共有メモリファイルが使えます。共有メモリとファイ
ルの区別はどうするかというと、ファイル名の先頭に、`@'（アットマーク）
があるかないかで判断します。アットマークがある時は、共有メモリとして扱
います。ないときは、普通のファイルとして扱います。また、共有メモリファ
イルには、ディレクトリというものはありません。だから、どのディレクトリ
にいても、同じようにアクセスできます。

　あと、ＣＩＬサーバでは、Ｘウインドウとのやりとりもこなします。これは、
imagedispをとおして、Ｘのイベントを取り込んだり、imagedispにイベントを
送ったりできます。簡単に、画像ベースのＸウインドウのプログラムが書けて
しまうのです。

　また、ＣＩＬサーバは共有メモリ、Ｘとのやりとりをするので、各ホストご
とに自分のＣＩＬサーバを起動する必要があります。



●ＣＩＬサーバの関連コマンド

　共有メモリ・ファイル・システムの操作には、以下のコマンドが用意されて
います。

	cills	- ls		リストをとる。
	cilcp	- cp		コピーする。
	cilrm	- rm		削除する。
	cilview	- imagedisp	サーバを通して表示する。

・cillsには、以下のオプションが使えます。

	-a	すべてのステータスを省略形式で出力します。
	-l	すべてのステータスを詳しく出力します。
	-h	簡単なヘルプを表示します。

・cilcpは、ファイル、共有メモリ関係なくコピーです。

・cilrmは、共有メモリ上のファイルを削除します。

・cilviewは、サーバを通して画像を表示します。一度表示されているファイ
ル名では、同じウインドウに表示され、新しく起動することはありません。デ
モや、デバッグ用にどうぞ。



●サーバの終りかた

　サーバの終り方に関連して、ちょっと、説明しましょう。

	１：サーバだけを終了して、共有メモリ・ファイル・システムはその
	　　まま。

		% cilserver -r

	２：共有メモリ・ファイル・システムをフォーマットし直す。

		% cilserver -c

	３：共有メモリ・ファイル・システムを解放する。

		% cilserver -f

共有メモリ・ファイル・システムは、そのマシンがリブートされるか、
cilserverで、意図的に解放されない限り、ずっと残ります。続けて作業する
時には、そのままでいいけど、間が空く時は、解放しておきましょう。フォー
マットは、共有メモリ上にあるファイルを削除するだけで、共有メモリ・ファ
イル・システムは、解放されません。いろいろ、使い分けて使って下さい。
